---
layout: post
title: "CHAT"
date: 2015-08-24
---
Today I'm starting this post to record my thoughts while looking into Kirk's self-written software -- CHAT. Although I don't know (a) how often I will update, (b) how useful the content will be, or (c) how long it will take to complete the post, it is pretty exiting that after almost 5 months I'm finally here! ^_^

During the past 6+ years Kirk has been working on CHAT alone in his spare time. Now Charles and me are helping him publicize this software. To start with let me give you a brief introduction of CHAT. CHAT stands for Convergent Haplotype Association Tagging. It is a computer program that we are developing to detect rare moderate penetrant mutations from GWA data sets. <b>The core of this method is a graph-theory based algorithm that systematically searches for subsets of individuals that share long range haplotypes</b>. The underlying assumption is that a small (but significant) subset of unrelated individuals have the same disease because they have inherited a moderate penetrant mutation from a distant common ancestor. Since the algorithm is computationally intensive (an NP-complete problem), we have been cooperating with the Renaissance Computational Institute (RENCI) and using their high-performance computing clusters. How powerful these machines are? "Consider the resources are limitless." said Erik Scott, a Senior Research Software Developer at RENCI. 

Previous work showed the success of CHAT in constructed and simulated data sets as well as real data sets. The program has been applied in several independent projects to search for the genetic basis (i.e., causal mutations) of and treatment targets for diseases such as Parkinson's disease, stroke, alcoholism, multiple sclerosis, lymphoid cancer, and lung cancer and smoking. These studies found that CHAT is more likely to be successful with phenotypes that have lower population prevalence. The next step is to test CHAT using additional real data sets as they become available. Our goal is to help establish the baseline rate for detecting clusters of individuals with long shared haplotypes and to establish collaboration to resequence several genes for a few subjects. 

When I first looked into the code of CHAT, my impression is that Kirk put into a lot of efforts to make this software fault tolerant when working with clusters. CHAT tries to break up the jobs to use the number of CPUs that are expected. If a job fails it will be restarted and is often broken up into smaller jobs. CHAT keeps track of finished jobs and tries to resume remaining or failed ones. Most output files have internal line count information, so that a corrupted file can be automatically detected. Files are usually checked once for completeness but also frequently checked for whether they are where they are supposed to be. The above settings are accomplished through a properties file and can be changed in some in the longest step (i.e., phasing). Any step can be reinitialized (organized as multiple beans in the properties file), but then all subsequent steps then need to reinitialized. The intermediate data is stored in a derby database. 

<h2>Playing with CHAT</h2>
In the package there is a test example folder called TestDebug that can be copied to a workspace as a test use case. This folder contains a genotype file that has just the data for a region on chromosome that contains the lrrk2 locus. 48 of the subjects in the pedigree file have a LRRK2 mutation that causes parkinsonsin's disease. The file lrrk_samples_save list the subjects. Not all of them are included in the analysis as CHAT excludes closely related individuals. Before running the test example, make sure you have done the following:
<ul>
<li>From root (chat) import  (by right click and choose import from the drop-down menu) an existing project into workspace for each of the sub directories. (i.e., chat-common, chat-prep, chat-core etc). The classes built in these directories are what that are actually executed.</li>
<li>Change the working directory to wherever you put the <i>TestDebug</i> folder (Debug configuration --> Arguments tab --> Working directory (click on "Other" and specify the path of the folder)</li>
</ul>
The "TestDebug" folder contains the minimal input files CHAT needed (specified at the beginning of the "CHAT.properties" file). If you prefer your own test data, please also create and format these files as instructed below. (Note: there is no need to name these files by specific extensions, e.g., .lgen, .map, or .sample; you can simply use ".txt" or nothing)
<ul>
<li>A raw genotype file (also referred to as the lgen file) with tab or comma delimited columns:<br/>
     <i>chromID,pos,rs,subjectID,genotype[,CONFIDENCE]</i><br/>
A lgen file corresponds to a single chromosome and each line in the file describes a subject's genotype of a particular marker SNP on that chromosome. The first five columns (required) provide detailed information on a marker: its located chromosome, physical position, <a href="http://www.ncbi.nlm.nih.gov/books/NBK44417/">rs number</a>, ID of the subject (individual), and genotype. The genotype data should be in single char format (e.g. 0,1,2 for AA, AG, GG) or <a href="http://www.bioinformatics.org/sms/iupac.html ">the IUPAC format</a> (e.g., A,R,G for AA, AG, GG). See the code file below for more information. The last column (optional) gives a float-type confidence value that can be used to filter the data. This file SHOULD be gzipped (end with .gz) to save space (required by the program). </li>
<li>A LDU map file: tab or comma delimited columns:<br/>
     <i>chromID,pos,rs,ldumap (-999999 for unknown place holder),in use bit</i></li>
The first three columns have the same meanings as in the lgen file. The fourth column (ldumap) indicates a particular marker's LDU (linkage disequilibrium unit) map position. The last column indicates whether or not this record will be used in later analysis: 0 means no use and 1 means use. 
<li>A sample file (also referred to as the fam file): tab or comma delimited SubjectID, DX (disease affection) {0 as unknown,1 as unaffected/control,2 as affected/case},Sex {2 female,1 male, 0 unknown},in use bit {0,1}</li> 
<li>A code file (also referred to as the truth table or truth matrix) indicates genotype coding strategy used in the data set. The first line gives the codes that represent homozygous geneotypes (e.g., A,C,G,T for AA, CC, GG, TT). The second line gives the codes of all possible genotypes (e.g., A,C,G,K,M,R,S,T,W,Y,X, if the IUPAC format is applied). These are also the horizontal and vertical elements of the truth table/matrix (referred to as truth vectors). Such a table checks compatibility. Regarding the IUPAC format, an "R" genotype can be either an "A" or a "G" genotype , i.e., an "R" is compatible with an "A" or a "G" (denoted as R = A or G). Thus, Y=C or T, S=G or C, W=A or T, K=G or T, M=A or C. In order to indicate that A is compatible with M, R, and X, "1" is assigned to the matrix cell AM, MA, AR, RA, AX, and XA. In contrast, "0" indicates incompatibility. Thus, a IUPAC code file should look like below (note that the placement of comma is critical for CHAT to correctly parse the truth matrix):
<pre><code>
,A,C,G,T
,A,C,G,K,M,R,S,T,W,Y,X 
A,1,0,0,0,1,1,0,0,1,0,1
C,0,1,0,0,1,0,1,0,0,1,1
G,0,0,1,1,0,1,1,0,0,0,1
K,0,0,1,1,0,1,1,1,1,1,1
M,1,1,0,0,1,1,1,0,1,1,1
R,1,0,1,1,1,1,1,0,1,0,1
S,0,1,1,1,0,1,1,0,0,1,1
T,0,0,0,1,0,0,0,1,1,1,1
W,1,0,0,1,1,1,0,1,1,1,1
Y,0,1,0,1,1,0,1,1,1,1,1
X,1,1,1,1,1,1,1,1,1,1,1
</code></pre></li>
</ul>
<h2>Major modules/steps of CHAT</h2>
<h3>Module 1</h3>
The first step/module is to convert input files into CHAT accepted format. It is controlled by the CHAT_prep.xml file in the same folder. The file defines all the <a href="http://stackoverflow.com/questions/17193365/what-in-the-world-are-spring-beans">spring beans</a> used to accomplished this step. Users can skip a particular bean by commenting out the corresponding ref bean line in the threadList of the XML file using <!-- statement -->.

The first three beans check the sanity of input files (users can scroll down in the "CHAT_prep.xml" file to see and modify the properties of each bean). "CheckLgenStructureRunnable" conducts sanity check on the lgen file. If there are any problematic genotype records (i.e., lines) in the file, the process will be terminated so that users can review detected problems, which are recorded in a "problemGenotypes.txt" file in the same folder. If no problem is detected, there won't be such a file (created and then deleted by the program). All "filtered" genotype records (obtained by stripping problematic and redundant lines) are outputted into a file named by adding a prefix "Filtered" to the the original sample lgen name. This file has the same format as the old file. If the user is willing to ignore (instead of trying to modify) all identified problem lines, he or she can set the "projectRawLongDataFileName" field in CHAT.properties (which is the field that indicates the lgen file to be used) to the file that contains all filtered genotype records (i.e., the one whose name starts with "Filtered"). Three other files can also be created during the process, although users can choose not to write any of them by commenting out corresponding property lines or setting the value to "" in the CHAT_prep.xml file. Among the three files, "GenotypeContainsChrom.txt" stores involved chromosomes (ordered by chromID), each per line. (b) "GenotypeContainsSamples.txt" stores involved subjects (ordered by subjectID), each per line with the format:<br/>
<i>subjectID,0 (place holder for unknown disease affection state),0 (place holder for unknown sex),1</i><br/>
(c) "GenotypeContainsSNPs.txt" stores involved marker SNPs (ordered by marker position), each per line with the format:<br/>
<i>chromID,pos,rsnumber,-77777.0 (place holder for unknown LDU map position),1</i><br/>

The second bean "CheckMapStructureRunnable" conducts sanity check on the LDU map file (required information and their number format and redundancy). If there are any problematic map elements in the file (one element as a line), the process will be terminated so that users can review detected problems (recorded in a "ProblemMapRecords.txt" file in the same folder). This bean mainly checks whether each record (i.e., each line) in the file has a unique rs number (the 3rd column/field), i.e., whether each SNP uniquely maps to a location. Two maps (data structure) are also created connecting each SNP (identified by its rs number) to its located chromosome (the 1st column/field) and physical position on that chromosome (the 2nd column/field) respectively. All "filtered" (i.e., non-problematic) map elements are sorted using their rs numbers and outputted into a file named by adding a prefix "FilteredSorted" to the old map file. This file has the same format as the old file. If the user is willing to ignore (instead of trying to modify) all identified problem lines, he or she can set the "projectMap" field in CHAT.properties (which is the field that indicates the map file to be used)  to the file that contains all filtered map records (i.e., the one whose name starts with "FilteredSorted"). Additionally, the bean can create a "MapContains<old map file name>.chrom" file listing all involved chromosomes (ordered by chromID), each per line (without redundancy). If users prefer, the bean also checks to see whether the map file contains all the SNPs in the "GenotypesContainsSNPs.txt" file outputted by the first bean (of course then that file must already exist). Any SNP in the previous file but missing in the map file will be outputted to a "SnpIdInGenotypeNotInMap.txt" file that has the same format as the previous file. If there are any SNPs mapped to more than one position or duplicate entries in the map, their information will be outputted to the screen  (i.e., standard output) and the process will be terminated.

The third bean "CheckFamStructureRunnable" conducts sanity check on the sample file (required information and their number format and redundancy). Any problematic sample element in the file (as a line) will be assigned -9 to its "include" "dx" and "sex" fields, so that it won't pass validity test. All problematic samples are outputted to a separate file named "problemSample.txt"; given no problem, this file will be automatically deleted. This bean mainly checks whether each record (i.e., each line) in the sample file has a unique sample ID (the 1st column/field). Duplicated sample lines are stripped and put in a file named by adding a prefix "dupSamples" to the original sample file name. All non-redundant sample elements are outputted into a file named by adding a prefix "FilteredSorted" to the old sample file; the list is sorted in the order of the "include" "dx" "sample ID" and "sex" fields subsequently. This file has the same format as the old file. If the user is willing to ignore (instead of trying to modify) all identified problem lines, he or she can set the "projectSamples" field in CHAT.properties (which is the field that indicates the map file to be used)  to the file that contains all filtered map records (i.e., the one whose name starts with "FilteredSorted"). If users prefer, this bean will check to see whether the sample file contains all the samples in the "GenotypesContainsSamples.txt" file outputted by the first bean. Missing samples will be outputted to a "SamplesIdInGenotypeNotInFamilyFile.txt" file that has the same format as the previous file but the "sex" and "dx" fileds of these sample records are changed to unknown and the "include" field to 0 (not included). Then the process will be terminated so that users can review these mismatched samples.

Then the filtered input information is further checked and reorganized. First you can filter out discordant SNPs (stored in an existing file probably named as "DiscordantMarkersToFilter.txt" in the same folder) using a bean named "RemoveListOfSnpsChat" (Why cancelled out in CHAT_prep.xml?). The next bean "MakeChromSpecificChatFromLgen" collects information from the above output files and rearranges them for each chromosome. The results are stored in a sub-directory of the work directory (i.e., TestDebug) named "ChromosomeSpecificData". Inside the folder are a few txt files, each corresponding to and named after a chromosome. The records/lines in these txt files are formatted as<br/>
<i>chromID,pos,rs number,subjectID,genotype,confidence</i>
<br/> If users are interested in not all but a subset of the chromosomes in the data set, they can specify the chromosome(s) of interest in a file beforehand (the "projectChromosomeList" field in the CHAT.properties file), so that only the chromosomes in the list will be further processed. During the process, the bean also checks to make sure that every SNP has corresponding records in both the filtered lgen file and the filtered map file. Another filtering criterion users can apply here is to set up a threshold for the qc (the "confidence" field).
