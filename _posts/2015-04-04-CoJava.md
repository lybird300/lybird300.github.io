---
layout: post
title: "COSI and Daniel's CoJava"
date: 2015-04-04
---

This post is dedicated to <a href="http://www.smithfuneralhomebroadway.com/fh/obituaries/obituary.cfm?o_id=2902785&fh_id=13749">Daniel Thomas Gillis</a>, Kirk's doctoral student and the author of CoJava who suddently and unexpectedly passed away three months ago.</p>

The <a href="https://popmodels.cancercontrol.cancer.gov/gsr/packages/cosi/">Cosi</a> program (Schaffner et al., 2005) implements a coalescent model similar to the MS program but allows for complex demographic histories and variable recombination rates. Both MS and Cosi implement the standard coalescent approach that simulates genealogical events backward in time. Simulated events typically include the coalescence of two DNA sequences into a single ancestral lineage, recombination within a sequence, or migration between populations. Since all these events are typically rare, coalescent simulators assume that they never occur simultaneously and assume many generations pass between consecutive events. Time between events is explicitly modeled and used to skip over generations with no genealogical events of interest. The algorithm proceeds until all sequences coalesce to their most recent common ancestor (MRCA) and the resulting genealogy is used to place mutation events along the various sequences.

Moreover, Cosi was calibrated (i.e., figure out the values of model parameters by fitting the model to some empirical data) using genome-wide human population data for different populations (deCODE genetic map). The resultant model is referred to as the "bestfit" model and the obtained parameter values (default) are listed in Table 1 in <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC1310645/">Schaffner et al's paper</a>.

<h2>Performance</h2>
Cosi is suitable for short genomic segments or gene sequences (<2-3Mb) but become very slow for larger regions (> 100Mb). As sequences get longer, many more coalescent, recombination and migration events occur and the time intervals between them diminish. For longer sequences and large sample sizes, little computational efficiency is gained by skipping over uninteresting generations and substantial computational effort is expended tracking recombination events and their positions, and allocating memory to track the many ancestral fragments of each sequence as they repeatedly recombine and coalesce with each other. As genome-wide studies become a reality, efficient tools for simulating large sequences are essential. Thus, it is necessary to improve cosi's performance in this aspect.

An improved algorithm -- <a href="http://csg.sph.umich.edu/liang/genome/">GENOME</a> (While in the standard coalescent algorithm, each coalescence event involves exactly two sequences that coalesce to a common ancestor, in GENOME, multiple sequences can coalesce to a common ancestor simultaneously. The interested readers are also refered to the author's doctoral dissertation -- "Efficient methods for analysis of genome scale data")

Daniel rewrote Cosi in Java and improved the original algorithm in two aspects.

He also incorporated chromosome anomalies into cosi, so CoJava is capable of...inversion, insertion, deletion.

You can find the source codes on <a href="https://github.com/dtgillis/Cojava">Dan's github site</a>. If you are a layman like me, you may want to check out<a href="https://github.com/lybird300/CoJava_linly_nov13">my commentory on Daniel's codes</a> (still working on it). The rest of this post describes how to use CoJava. 

<h2>Input parameters</h2>
The parameters of CoJava are mostly the same as those of <a href="http://lybird300.github.io/2015/04/02/cosi-overview.html">Cosi</a>, except for the following:
